<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>UBC Library Research Commons workshops</title>
  <style>
    body {
      font-family: sans-serif;
      padding: 2rem;
      max-width: 800px;
      margin: auto;
    }
    h1 {
      font-size: 1.8rem;
      color: #003366;
    }
    h2 {
      margin-top: 2rem;
      font-size: 1.4rem;
      color: #0055aa;
    }
    ul {
      list-style: none;
      padding-left: 0;
    }
    li {
      margin-bottom: 1rem;
    }
    a {
      color: #0055aa;
      text-decoration: none;
    }
    a:hover {
      text-decoration: underline;
    }
    .archived {
      font-style: italic;
    }
  </style>
</head>
<body>
  <h1>UBC Library Research Commons workshops</h1>
  <div id="repo-sections"></div>

  <script>
    const TOPIC_LABELS = {
      data: 'Data analysis and visualization',
      geospatial: 'Geographic information systems (GIS) and mapping',
      'digital-scholarship': 'Digital scholarship'
    };

    async function loadRepos() {
      try {
        const response = await fetch('https://api.github.com/orgs/ubc-library-rc/repos?per_page=100', {
          headers: { 'User-Agent': 'github-pages-script' }
        });

        if (!response.ok) throw new Error(`Repo list fetch failed: ${response.status}`);

        const repos = await response.json();

        const enrichedRepos = await Promise.all(repos.map(async repo => {
          try {
            const topicRes = await fetch(repo.url + '/topics', {
              headers: {
                'Accept': 'application/vnd.github.mercy-preview+json',
                'User-Agent': 'github-pages-script'
              }
            });
            if (!topicRes.ok) throw new Error(`Topic fetch failed for ${repo.name}`);
            const topicData = await topicRes.json();
            return {
              name: repo.name,
              description: repo.description,
              url: `https://ubc-library-rc.github.io/${repo.name}/`,
              archived: repo.archived,
              topics: topicData.names || []
            };
          } catch (topicErr) {
            console.warn(topicErr.message);
            return null; // Skip if topic fetch fails
          }
        }));

        const filteredRepos = enrichedRepos.filter(repo => repo && repo.description);

        const grouped = {};
        for (const topic in TOPIC_LABELS) {
          grouped[topic] = filteredRepos
            .filter(repo => repo.topics.includes(topic))
            .sort((a, b) => a.description.localeCompare(b.description));
        }

        const container = document.getElementById('repo-sections');
        for (const topic in TOPIC_LABELS) {
          const repos = grouped[topic];
          if (!repos || repos.length === 0) continue;

          const section = document.createElement('section');
          const heading = document.createElement('h2');
          heading.textContent = TOPIC_LABELS[topic];
          section.appendChild(heading);

          const list = document.createElement('ul');
          for (const repo of repos) {
            const item = document.createElement('li');
            const link = document.createElement('a');
            link.href = repo.url;
            link.target = '_blank';
            link.rel = 'noopener noreferrer';

            let linkText = repo.description;
            if (repo.archived) {
              linkText += ' (archived)';
              link.classList.add('archived');
            }

            link.textContent = linkText;
            item.appendChild(link);
            list.appendChild(item);
          }

          section.appendChild(list);
          container.appendChild(section);
        }
      } catch (err) {
        console.error('Failed to load repositories:', err);
      }
    }

    loadRepos();
  </script>
</body>
</html>
